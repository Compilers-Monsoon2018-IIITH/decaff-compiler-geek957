%{
	#include <bits/stdc++.h>
	#include "ast.h"
	extern FILE *yyin;
	extern char* yytext;
	extern "C" int yylex();
	extern int yyparse();
	extern FILE *yyin;
	extern int line_num;
	extern int errors;
	void yyerror(const char *s);
	int errors=0;
	class Program* start = NULL;
%}

%union{
  	int number;
  	char *str;
 	//char *an;
	//char *identifier_val;
  	//char *rel;
	//char *con;
	//char *ari;
	class Program *pro;
	class Field_declarations *fd_ds;
	class Field_declaration *fd_d;
	class Var_declarations *vr_ds;
	class Var_declaration *vr_d;
	class Method_declarations *md_ds;
	class Method_declaration *md_d;
	class Method_args_declarations *md_ag_ds;
	class Method_args_declaration *md_ag_d;
	class Block *blk;
	class Field_method_declarations *fd_md_ds;
	class Field_method_declaration *fd_md_d;
	class Var_method_declarations *vr_md_ds;
	class Var_method_declaration *vr_md_d;
	/*class declarlist *decllis;
	class decl *decla;
	class idlist *idlino;
	class id *idno;
	class statlist *stlino;
	class stat *stno;
	class ass *assno;
	class ifs *ifsno;
	class fors *forsno;
	class whiles *whileno;
	class lab *labno;
	class gotos *gono;
	class read *readno;
	class print *printno;
	class bl *blno;
	class expr *exprno;
	class numb *numno;
	class lf *lfno;
	class ab *abno;
	class id1 *id1no;*/
  }



%token CLASS
%token PROGRAM
%token <str> TYPE
%token <str> VOID
%token IF
%token FOR
%token RETURN
%token BREAK
%token CONTINUE
%token ELSE
%token CALLOUT
%token BOOL_LIT
%token GE
%token LE
%token PLE
%token SUE
%token EE
%token NE
%token EXCL
%token '='
%token GT
%token LT
%token PLUS
%token MINUS
%token MUL
%token DIV
%token MOD
%token AND
%token OR
%token ','
%token '}'
%token '{'
%token ']'
%token '['
%token ')'
%token '('
%token ';'
%token <number> INT_LIT
%token CHAR
%token STRING
%token <str> ID

%left EE NE
%left AND OR
%left LT GT LE GE
%left PLUS MINUS
%left MUL DIV MOD
%right EXCL '='

%type <pro> program
%type <fd_ds> field_decls
%type <fd_d> field_decl
%type <vr_ds> vars_array_incl
%type <vr_d> var_array_incl
%type <md_ds> method_decls
%type <md_d> method_decl
%type <md_ag_ds> meth_arg_decls
%type <md_ag_d> meth_arg_decl
%type <blk> block
%type <fd_md_ds> field_method_decls 
%type <fd_md_d> field_method_decl
%type <vr_md_ds> vars_method
%type <vr_md_d> var_method 




%%
program : CLASS  PROGRAM '{' field_decls method_decls '}' 
							{
  								$$ = new Program($4, $5);
    							start = $$;
  							}
		| CLASS  PROGRAM '{' field_decls '}'
							{
  								$$ = new Program($4, NULL);
    							start = $$;
  							}
		| CLASS  PROGRAM '{' method_decls '}'
							{
  								$$ = new Program(NULL, $4);
    							start = $$;
  							}
		| CLASS  PROGRAM '{' '}'
							{
  								$$ = new Program(NULL, NULL);
    							start = $$;
  							}

/* FIELD DECLARATIONS */
field_decls : field_decl 
					{$$ = new Field_declarations(); $$->Push_back($1);}
			| field_decls field_decl 
					{$$->Push_back($2);}

field_decl : TYPE vars_array_incl ';'
					{$$ = new Field_declaration(string($1), $2);}

vars_array_incl : var_array_incl 
					{$$ = new Var_declarations(); $$->Push_back($1);}
				| vars_array_incl ',' var_array_incl
					{$$->Push_back($3);}

var_array_incl : ID 
					{$$ = new Var_declaration(string($1));}
			   | ID '[' INT_LIT ']'
			   		{$$ = new Var_declaration(string($1),$3);}

/* METHOD DECLARATIONS */
method_decls : method_decl
				{$$ = new Method_declarations(); $$->Push_back($1);} 
			 | method_decls method_decl
			 	{$$->Push_back($2);}

method_decl : TYPE ID '(' meth_arg_decls ')' block
				{$$ = new Method_declaration(string($1), string($2), $4, $6);}
			| TYPE ID '(' ')' block
				{$$ = new Method_declaration(string($1), string($2), NULL, $5);}
			| VOID ID '(' meth_arg_decls ')' block
				{$$ = new Method_declaration(string($1), string($2), $4, $6);}
			| VOID ID '(' ')' block
				{$$ = new Method_declaration(string($1), string($2), NULL, $5);}

meth_arg_decls : meth_arg_decl 
					{$$ = new Method_args_declarations(); $$->Push_back($1);}
			   | meth_arg_decls ',' meth_arg_decl
			   		{$$->Push_back($3);}

meth_arg_decl : TYPE ID
					{$$ = new Method_args_declaration(string($1), string($2));}

block : '{' field_method_decls statements '}'
			/*{$$ = new Block($2, $3);}*/
	  | '{' field_method_decls '}'
	  		{$$ = new Block($2);}
	  | '{' statements '}'
	  		/*{$$ = new Block();}*/
	  | '{' '}'
	  		{$$ = new Block(NULL);}

field_method_decls : field_method_decl
						{$$ = new Field_method_declarations(); $$->Push_back($1);}
			  	   | field_method_decls field_method_decl
			  	   		{$$->Push_back($2);}

field_method_decl : TYPE vars_method ';'
						{$$ = new Field_method_declaration(string($1), $2);}

vars_method : var_method
				{$$ = new Var_method_declarations(); $$->Push_back($1);}
			| vars_method ',' var_method
				{$$->Push_back($3);}

var_method : ID {$$ = new Var_method_declaration(string($1));}


statements : statement 
		   | statements statement

statement : location assign_op expr ';'
 		  | method_call ';'
 		  | IF '(' expr ')' block ELSE block
 		  | IF '(' expr ')' block
 		  | FOR ID '=' expr ',' expr block
 		  | RETURN expr ';'
 		  | RETURN ';'
 		  | BREAK ';'
 		  | CONTINUE ';'
 		  | block



assign_op : '='
		  | PLE
		  | SUE 

method_call : ID '(' exprs ')'
			| ID '(' ')'
			| CALLOUT '(' STRING  callout_args ')'
			| CALLOUT '(' STRING ')'

exprs : expr
	  | exprs ',' expr

callout_args : ',' callout_arg 
			 | callout_args ',' callout_arg

callout_arg : expr
			| STRING

location : ID
		 | ID '[' expr ']'

expr : location
	 | method_call
	 | lit
	 | expr PLUS expr
	 | expr MINUS expr
	 | expr MUL expr
	 | expr DIV expr
	 | expr MOD expr
	 | expr LT expr
	 | expr GT expr
	 | expr LE expr
	 | expr GE expr
	 | expr EE expr
	 | expr NE expr
	 | expr AND expr
	 | expr OR expr
	 | MINUS expr
	 | EXCL expr
	 | '(' expr ')'


lit : INT_LIT
	| CHAR
	| BOOL_LIT


/*int_lit : NUMBER {$$ = new Int_lit($1);}
		| HEX_NUMBER {$$ = new Int_lit($1);}
*/


/*bool_lit : TRUE
		 | FALSE*/




%%

main(int argc, char **argv)
{
	if(argc == 1)
    {
		fprintf(stderr, "Correct usage: bcc filename\n");
		exit(1);
	}
	if(argc > 2)
    {
		fprintf(stderr, "Passing more arguments than necessary.\n");
		fprintf(stderr, "Correct usage: bcc filename\n");
	}
	printf("About to start\n");
	yyin = fopen(argv[1], "r");
	yyparse();
	DFS* dfs;
	dfs=new DFS();
	start->accept(dfs);
	printf("Parsing Over\n");
}

void yyerror(const char *s)
{
	fprintf(stderr, "error: %s\n", s);
}